package EncryptExport;

/* AUTHOR INFORMATION
 * CREATOR - Jeremy Dunnet 02/10/2018
 * LAST MODIFIED BY - Jeremy Dunnet 05/10/2018
 */

/* CLASS/FILE DESCRIPTION
 * This class is responsible for taking a user's retrieved data and encrypting it according to the AES standard of encryption
 * for transport across the net to be delivered to a server.
 */

/* VERSION HISTORY
 * 02/10/2018 - Created file and added comment design path for future coding
 * 05/10/2018 - Added a lot of base functionality according to research and loaded with comments for both understanding and future development use
 */

/* REFERENCES
 * The main basis for this code was adapted/learned from https://stackoverflow.com/questions/6788018/android-encryption-decryption-with-aes
 * The reasoning's behind uses of certain modes and Objects was learned from personal research summary, https://medium.com/@tiensinodev/basic-android-encryption-dos-and-don-ts-7bc2cd3335ff and https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9
 * Keystore use was learned from https://medium.com/@josiassena/using-the-android-keystore-system-to-store-sensitive-information-3a56175a454b
 * GCM padding learned from https://crypto.stackexchange.com/questions/42412/gcm-padding-or-not
 * Reason for using a charset in string byte encoding learned from http://www.java67.com/2017/10/3-ways-to-convert-string-to-byte-array-in-java.html
 * And all related documentation on https://developer.android.com
 */

import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

class Encrypt
{

    /* FUNCTION INFORMATION
     * NAME - encryptHandler
     * INPUTS - userFile (file to be encrypted)
     * OUTPUTS - encrypted (encrypted version of userFile)
     * PURPOSE - This is the function to begin the encryption process on the userFile provided
     */
    public static Object encryptHandler(Object userFile) throws Exception {

        //SAMPLE TEST STRING BEFORE USING FILE RETRIEVAL
        String testString = "Hello - I have secret info I want to send";

        //These are variables you can use to alter how the encryption functions - I have initialised them here instead of hardcoding
        //them into the function calls so whatever encryption type/specifications you need can be easily altered here (also present in private function as well!)
        String algorithm = "AES"; //The variable for determining what encryption standard you wish to encrypt the data in
        String keyStore = "AndroidKeyStore"; //The variable for the KeyStore you wish to use - Android is most reliable (but can be changed to whatever you use)
        String charSet = "UTF-8"; //The variable for What charset you will use to encode the string bytes as -  this is so you receive less hiccups in transfer across different systems
                                  //This was sourced from references above (http://www.java67.com/2017/10/3-ways-to-convert-string-to-byte-array-in-java.html and https://medium.com/@tiensinodev/basic-android-encryption-dos-and-don-ts-7bc2cd3335ff)
        int keySize = 128; //The variable for the size of the key you want

        //IMPORTANT - THIS CODE SHOULD BE IMPLEMENTED WHEN MOVING TO FULL SERVER BASED APP
        //This is the basic code outline for what you should be doing when encrypting using a server to handle communications between user phones and a central database
        //The database would be running a Certificate Authority (CA) that controls and distributes the encryption keys across the network
        /* Connect to server CA and request certification
         * This certificate will include what AES keys are valid for this transaction
         * Then the valid keys should be stored in the AndroidKeyStore (for extra security in using the keys) using the below KeyGenerator code (!KEY)
         * NOTE: You can move the server handshake (and KeyGenerator code) to any part of the app you want (since KeyStore is a OS level Object) - then just grab the generated key using:
         *  keyStore = KeyStore.getInstance("AndroidKeyStore"); //Grab an instance of the AndroidKeyStore
         *  keyStore.load(null);
         *  final KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore.getEntry(alias, null);
         *  final SecretKey secretKey = secretKeyEntry.getSecretKey(); //Get the stored key
         */

        // (!KEY - start) Store all keys generated by this KeyGenerator into the keystore
        final KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm, keyStore);

        //ByteArrayOutputStream baos = new ByteArrayOutputStream(); UNUSED OLD CODE FROM REFERENCE _ DELETE ONCE MY VERSION TESTED!!!!
        //bm.compress(Bitmap.CompressFormat.PNG, 100, baos); // bm is the bitmap object UNUSED OLD CODE FROM REFERENCE _ DELETE ONCE MY VERSION TESTED!!!!
        //Transform user data from string to byte array (what most encryption methods use)
        byte[] b = testString.getBytes(charSet);

        //Create a seed for your random number generator
        byte[] keyStart = "this is a key".getBytes(); //TODO - consider deleting/refactoring to another way
        //KeyGenerator kgen = KeyGenerator.getInstance("AES"); UNUSED OLD CODE FROM REFERENCE _ DELETE ONCE MY VERSION TESTED!!!!
        //Create a cryptographic strength random number generator
        SecureRandom sr = new SecureRandom( /*genType*/ ); //genType is the chosen style of randomisation - my research has said that leaving the generation style to Android defaults is not major differnce
                                                           //But you may change to whatever type you want - DO NOT USE "SHA1PRNG" as articles online claim this is not as random as was thought!
        //Seed the SecureRandom
        sr.setSeed(keyStart);
        //Initialise the KeyGenerator to the size of the key we want and hwo to randomly generate data for it
        keyGenerator.init(keySize, sr);
        //Store the generated key in a SecretKey object (Android provides this interface to increase secure access to the key itself)
        SecretKey skey = keyGenerator.generateKey();
        //Get byte version of key (for use in encrypting)
        byte[] key = skey.getEncoded();

        //Encrypt the data
        byte[] encryptedData = encrypt(key,b);

        return encryptedData;

    }

    //TODO - see if can do instanceof specific exceptions
    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception
    {
        //Another set of variables you can modify to alter how this method encrypts your data
        String algorithm = "AES"; //The variable for the algorithm type of the key you are going to use
        String cipherAlgorithm = "AES/GCM/NOPADDING"; //The variable for what type of encryption you are going to use
                                                      //I have used AES (Current Australian Signals Directorate standard) with
                                                      //GCM (Galois/Counter Mode - this was most commonly used and provides authentication as well as encryption - see reference below)
                                                      //and a no padding option (since GCM uses a stream cipher style - no padding is needed)
                                                      //DO NOT USE ECB (Electronic Codebook) as a mode (included as a restriction in ASD standard as do not use) - as this mode resuses the same key on each block of plaintext, meaning identical blocks will encrypt the same (VERY BAD!!!!)
                                                      //https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

        //SecretKeySpec is another interface to increase security
        SecretKeySpec skeySpec = new SecretKeySpec(raw, algorithm);
        //Get a Cipher instance that will encrypt our data according to the algorithm we choose
        Cipher cipher = Cipher.getInstance(cipherAlgorithm);
        //Initialize the cipher with our key and tell it we only want it to encrypt or data right now
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        ///Do the encryption
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

}
